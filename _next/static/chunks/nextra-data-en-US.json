{"/about":{"title":"About","data":{"":"This page references how is build this project and which Library are used.","architecture#Architecture":"Here's a high-level overview of the architecture:","front-end#Front-end:":"User Interface (UI): The front-end component handles the presentation layer of the application and provides an interface for users to interact with the TODO application.","scalajs#ScalaJS":"The frontend application is build using ScalaJS.Scala.js is a powerful framework that harnesses the Scala and JavaScript ecosystems,\nenabling the development of robust applications for browsers, Node.js, and serverless environments.\nWith its strong typing, Scala.js ensures code correctness, eliminating common mistakes such as mixing\ndata types and typos in method names. It optimizes Scala code into highly efficient JavaScript,\noffering fast compilation times and generating compact output starting from 45kB gzipped.Scala.js seamlessly integrates with popular JavaScript libraries like React and AngularJS,\nproviding excellent interoperability.\nThe framework also offers exceptional editor support,\ncatching typos and type-errors instantly, providing in-line documentation,\nand facilitating effortless refactoring. Unlock the potential of Scala and\nJavaScript with Scala.js for building performant applications with a seamless development experience.","backend#Backend:":"Application Server: The back-end component handles the business logic and data management of the application. It receives requests from the front-end, processes them, interacts with the database, and returns the appropriate response.API (Application Programming Interface): The back-end exposes a set of RESTful or GraphQL APIs that the front-end can consume to perform CRUD (Create, Read, Update, Delete) operations on TODO items. The APIs handle the data validation, authentication, and authorization aspects of the application.\nDatabase: A persistent storage system is needed to store the TODO items. Common choices include relational databases like MySQL, PostgreSQL, or non-relational databases like MongoDB.ZIO is used for the REST API.","zio#ZIO":"ZIO is a powerful library for Scala that provides type-safe, composable, and concurrent programming capabilities.\nWith ZIO, you can easily build scalable applications that outperform Scala's Future by a factor of 100.By leveraging the full power of the Scala compiler, ZIO enables you to catch bugs at compile time, ensuring type safety and robustness in your codebase.\nZIO simplifies the development of concurrent applications, eliminating common issues like deadlocks, race conditions, and complexity.It allows you to write sequential code that remains consistent, whether it's executed asynchronously or synchronously. Additionally, ZIO promotes resource-safe practices, preventing resource leaks even in the face of failures.It offers excellent testability, allowing you to inject test services into your application for fast, deterministic, and type-safe testing. ZIO empowers you to build resilient applications that handle errors gracefully and respond to failures locally and flexibly.With its functional programming approach, ZIO enables rapid composition of solutions to complex problems using simple building blocks.","architecture-1#Architecture":"This architecture provides a basic structure for a TODO Fullstack application, but keep in mind that specific implementation details and technologies may vary based on individual preferences, project requirements, and scalability considerations.The architecture consists of a frontend application and a backend built with ZIO and Scala.js.\nThe frontend application provides a user interface for managing TODOs, while the backend exposes an API to interact with the TODOs data.The frontend application, developed with Scala.js, benefits from the seamless integration with ZIO, enabling the use of reactive components and ensuring high-performance.","authors#Authors":"This project was written by the following:","how-to-start-#How to start ?":"You can start to play with this project with the Quick start."}},"/deploy":{"title":"Deploy","data":{"":"","deploy-fss-in-production#Deploy FSS in production":"This tutorial explains how to deploy the Fullstack Scala Application in production with Docker.For this example, we will use nginx-proxy-manager.\nThe Nginx Proxy Manager is a basic interface for beginners and advanced users to create different types of Hosts to proxy their incoming home network traffic.\nThis tool will allow us to proxy ingress traffic to specific containers on the host machine, from a understandable UI.Follow the guide 🦮","create-a-nginx-proxy-manager-container#Create a nginx-proxy-manager container":"For this first step, you should define two domain name.\nOne for the frontend and the other for the backend.\nIn this example we will use example.com for the frontend and api.example.com\nCreate a folder nginx-proxy-manager and paste the following code into a docker-compose.yml file:\nversion: '3.9'\n\nservices:\nnginx-proxy-manager:\nimage: jc21/nginx-proxy-manager:2.9.19\nrestart: unless-stopped\nports:\n# Public HTTP Port:\n- '80:80'\n# Public HTTPS Port:\n- '443:443'\n# Admin Web Port:\n- '81:81'\nvolumes:\n- ./data:/data\n- ./letsencrypt:/etc/letsencrypt\nhealthcheck:\ntest: [\"CMD\", \"/bin/check-health\"]\ninterval: 10s\ntimeout: 3s\nnetworks:\n- web-proxy\n```docker filename=\"/nginx-proxy-manager/docker-compose.yml\"\n[...]\nnetworks:\nweb-proxy:\nRun the container with :\ndocker compose up -d\nNow let's launch our application !","modify-the-docker-compose#Modify the docker-compose":"To deploy in production the project, a docker-compose file is written at the root of the directory, which exposes the application and\nthe chooses database.We now need to bind the services to the external nginx-proxy-manager_web-proxy network.To do so add an external network.\nGet back into your application folder and modify the docker-compose.yml:// TODO: Add the FINAL Docker compose\n[...]\nnetworks:\nnginx-proxy-manager_web-proxy:\nexternal: true\nChange the value of API_URL for the value defined in the first step (api.example.com) for our example.Launch the docker-compose:\ndocker-compose up -d\nNow let's expose our services on Internet","expose-our-application-on-internet#Expose our application on Internet":"","create-proxy-host#Create Proxy Host":"Retrieve your IP:\ncurl ifconfig.me\nOpen your browser with the following url: <IP>:81/.","add-a-proxy-host-for-the-frontend#Add a proxy host for the Frontend":"Click on the button Add Proxy Host\n\nAdd the information:\nDomain Name:\nThe value of the FRONTEND_URL Defined in Step 1.1.\nScheme: http\nForward Hostname / IP : http\nForward Port : 3000\n\nNow let's define the SSL with the following:","add-a-proxy-host-for-the-backend#Add a proxy host for the Backend":"Click on the button Add Proxy HostAdd the information:\nDomain Name:\nThe value of the API_URL (api.example.com) Defined in Step 1.2.\nScheme: http\nForward Hostname / IP : http\nForward Port : 8080\n\nNow let's define the SSL with the following:\n\nGreat ! We now need to define DNS Record.","create-dns-record#Create DNS Record":"The application needs two DNS records to work properly:\nFrontend\nName: <domain_name> example.com\nType: A\nContent: <your-server-public-ip>\n\n\nBackend\nName: api.<domain_name> api.example.com\nType: A\nContent: <your-server-public-ip>\n\n\n\n\nCongrats your application is deployed 🥳Now let's open your browser at example.com to check it out !"}},"/going_further":{"title":"Overview","data":{"":"In this section, we will describe the backend architecture and see how to modify the CRUD.","file-presentation#File Presentation":"main.scala: This file serves as the entry point of the application. It launches an HTTP server that listens on a specified port (or the default port 8080). The server is configured to use the routes defined in TodoController.routes.\ntodo.scala: This file defines the structure of a todo task, including its properties such as ID, title, and completion status. It also provides implementations for encoding and decoding todos to JSON. To create your own structure, you need to define the object as a case class. Don't forget to implement the JSON encoder.\nDB.scala: This file handles the configuration and connection to the database. There are two versions: one for PostgreSQL and one for MongoDB. Environment variables are used to retrieve the database connection information. For PostgreSQL, a JDBC connection is established, while for MongoDB, a MongoDB client is created to interact with the database. You normally don't need to modify this file.\nTodoController.scala: This file handles the HTTP routes for todo-related operations. It defines the CORS configuration and specifies the base path for the routes. The routes call the corresponding functions in TodoService.\nTodoService.scala: This file contains the business logic for the application. It defines functions for interacting with the database, such as retrieving todos, creating a new todo, updating a todo, and deleting a todo.","implementation#Implementation":"","route#Route":"To implement a new route, follow the structure below:\ncase Method.GET -> BasePath => {\nTodoService\n.getTodos()\n.map(_.toJson)\n.map(Response.text(_))\n.orElse(\nZIO.succeed(\nResponse.fromHttpError(\nHttpError.NotFound(\"No todos found\")\n)\n)\n)\n}\nThe function corresponds to an HTTP GET route to fetch all todos.TodoService.getTodos() is called to retrieve all todo tasks from the database. This operation returns a ZIO effect encapsulating a sequence of tasks.Using the map method, the retrieved tasks are transformed into JSON using the implicit JSON encoder (see DB.scala). map is used again to create an HTTP response containing the JSON string.If the TodoService.getTodos() operation fails, the orElse block is executed. It returns an HTTP error response with the 404 (Not Found) status code and a message indicating that no todos were found.To implement your own route, you should follow the same general structure:\nDetermine the path and associated HTTP method.\nUse ZIO operations to interact with data sources.\nTransform the obtained results into an appropriate HTTP response.\nHandle potential errors using ZIO combinators.","service#Service":"def createTodo(title: String): Task[Todo] =\nfor {\ntodos <- getTodos()\nnewId = todos.map(_.id).max + 1\nnewTodo = Todo(newId, title, false)\n_ <- ZIO\n.fromFuture(_ => todosCollection.insertOne(newTodo).toFuture())\n.unit\n} yield newTodo\nThe createTodo function is responsible for creating a new todo. It takes the title of the new task as a parameter.The function starts by calling getTodos() to retrieve all existing todos. This returns a ZIO effect encapsulating the sequence of current tasks. The sequence of tasks is then mapped to extract the maximum ID value. This ensures that the new ID will be unique.Using the provided title parameter, a new instance of the Todo structure is created with the completed status initialized to false.An effect ZIO is created using ZIO.fromFuture to execute an asynchronous operation. The insertion operation is performed using todosCollection.insertOne(newTodo).toFuture().To implement your own function, you can follow the structure and patterns used in the TodoService functions. The only limit is your imagination.Once finished, you should check how to deploy the application in production 🚀"}},"/":{"title":"A TODO Application","data":{"":"This scaffolding project expose a typical architecture for a TODO Fullstack application would consist of both front-end and back-end components.\n\n\nThe Frontend view of the ScalaJS Fullstack Frontend applicationThis projects aims to provide a fullstack Scala Web Application\nusing ScalaJS, Zio, and a way to persist information in at least one database management system.","features#Features":"🚀 Discover the amazing features of our TODO Application! 🌟\nEasy project setup with a ready-to-use Frontend and Backend application. Get started in no time! 😎\n\n2️. Choose your favorite database with just one click: Postgres or MongoDB. It's all about flexibility! 🗃️3️. Seamlessly deploy your project using Docker. It's smooth sailing all the way! 🐳Don't miss out on this opportunity to build your dream full-stack application with ScalaJS and Zio. Get productive and unleash your creativity today! 💪🔥","a-scaffolding-project#A Scaffolding project":"In computer science, scaffolding refers to a technique or practice used in software development to provide a temporary\nframework or support structure for building applications.\nIt is a process of creating a basic structure or skeleton code\nthat helps developers quickly set up the foundation of an application\nor system before adding specific functionalities.Scaffolding typically involves generating or auto-generating code, templates, or frameworks\nthat provide a starting point for development.\nThis can include boilerplate code, directory structures,\nmodels, user interfaces, or other components that are commonly needed in an application.\nThe purpose is to streamline the development process,\nreduce repetitive tasks, and accelerate the initial setup of a project.\n\nScaffolding tools or frameworks are often used in web development,\nwhere they can generate basic code templates for creating models, views,\ncontrollers, database migrations, and other components of a web application.\nThese tools enable developers to quickly establish a project's structure and focus on implementing the specific business logic or features without starting from scratch.Scaffolding can be particularly useful in rapid prototyping,\nwhere speed is prioritized over fine-grained customization.\nOnce the scaffolding is in place, developers can modify or\nextend the generated code to meet the specific requirements of the application.","what-to-do-next-#What to do next ?":"You can dive into the structure of the application in the about section."}},"/quick_start":{"title":"Getting started with Scala Fullstack Scaffold","data":{"":"This page will helps you to quickly start developing your Scala Fullstack application.","install-the-required-tools#Install the required tools":"First, you need to have all the required tools to develop the application.👉 Check the requirement section.","build-your-project#Build your project":"First, let's build your fullstack application 🏗️This scaffolding project allows you to customize some value.\nTo do so, you should scaffold the application with sbt:\nsbt new do4-2022/scala-fullstack-scaffold.g8\n\nIt will outputs some Questions about the configuration of the application:\nThis a scaffolded app created with Gitter8\n\nname [My Fullstack App]:","customization#Customization":"Subsequent questions permits to define:\nThe name of the project\nThe default value is My Fullstack App.\nThe name of the Frontend application\nThe default value is My Fullstack App frontend.\nThe name of the Frontend application\nThe default value is My Fullstack App frontend.\nThe SBT version used\nThe default value is latest. You can use a semantic defined version.\nThe Database used\n\n\npostgres=yes\n\nBy setting the value to no, a MongDB Database will be used instead.\nOnce finished, a new folder name [My Fullstack App] will be created, containing the frontend and the backend applications.Here is the generated folder structure:\n<project_name>/\n├─ <frontend_name>/\n├─ <backend_name>/\n\nNow that the project is setup, you will have to launch both application, let's start with the backend !","launch-the-backend#Launch the backend":"Run the following command:\ncd ./backend\nsbt run","launch-the-frontend#Launch the frontend":"cd ./frontend\n# Install dependencies\nnpm install\n# Run the project in development\nnpm run dev\nNow, open your browser at the following localhost:3000 and see the magic happen 🌟.","start-coding-#Start coding !":"Congrats, you're all done for this tutorial !You can now start building your own Application.\nYou are done with the setup, now you can performs some changes to see if everything is working as expected:Open the header.scala file and Change the title with My Todo :\npackage My_Fullstack_App_frontend.components\nimport com.raquo.laminar.api.L.{given, *}\nimport My_Fullstack_App_frontend.events.commandObserver\nimport My_Fullstack_App_frontend.events.Reload\n\n// header of the app\ndef header() = {\ndiv(\ncls(\"header\"),\nh1(\"Todo\"),\nerrorMessage(),\ndiv(\ncls(\"top-bar\"),\nbutton(\n\"reload\",\ncls(\"reload\"),\nonClick.mapTo(Reload) --> commandObserver\n)\n),\nnewTodoInput\n)\n}\n\nSave your file and open the Changes in your browser 🤩\nNow, to start play with, you should check how the backend works and how to modify it in the next section"}},"/requirements":{"title":"Requirements","data":{"":"To start developing this project, you will need the following tools installed on your computer:","scala#Scala":"Scala is a statically typed programming language that seamlessly combines object-oriented and functional programming paradigms. It runs on the Java Virtual Machine (JVM) and provides powerful abstractions and expressive syntax.\nWith Scala, developers can write concise and scalable code, leverage Java libraries, and build robust applications across various domains.\n\n\nFunctional programming is a programming paradigm that emphasizes immutability, pure functions, and declarative style.\nIt encourages the use of functions as first-class citizens and avoids mutable state and side effects.\nFunctional programming promotes writing code that is easier to reason about, test, and maintain.To learn more about functional programming in Scala, you can refer to the official Scala documentation.","sbt#Sbt":"Sbt (Scala Build Tool) is a popular build tool for Scala projects. It offers a flexible and declarative configuration approach, allowing developers to define project settings, dependencies, and tasks in a concise manner. Sbt provides comprehensive support for compiling, testing, packaging, and running Scala applications, making it an essential tool for managing and automating the build process.","giter8#Giter8":"Giter8 is a simple and lightweight templating tool for generating projects from project templates stored in Git repositories. It allows developers to quickly bootstrap new projects by applying predefined templates, reducing the initial setup time. Giter8 templates provide a consistent project structure and include commonly used libraries, configurations, and best practices, enabling faster project kick-starts.","nodejs#Node.JS":"Node.JS is a JavaScript runtime built on the V8 JavaScript engine. It allows developers to execute JavaScript code outside the browser, on the server-side. Node.js provides an event-driven, non-blocking I/O model, which makes it highly efficient for building scalable and real-time applications. It also offers a rich ecosystem of modules through its package manager, npm, enabling developers to easily integrate third-party libraries and tools into their Node.js applications.","npm#npm":"npm (Node Package Manager) is the default package manager for Node.js. It is a vast registry of open-source JavaScript packages that developers can use to enhance their Node.js projects. npm provides a command-line interface and a comprehensive set of tools to manage dependencies, install packages, publish and share code, and handle project configurations. It simplifies the process of integrating external libraries and managing project dependencies, making it an essential tool for Node.js developers."}}}